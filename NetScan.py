from scapy.all import *
import sys
import random
import threading
import argparse
from threading import Thread
from queue import Queue

track = {}
print_lock = threading.Lock()
class Mythread(Thread):
    q = Queue()
    def __init__(self, func, args):
        threading.Thread.__init__(self)
        #self.number = number
        self.func = func
        self.args = args


    def run(self):
        try:
            if self.func:
                self.func(*self.args)
        finally:
            del self.func, self.args

def port_scan(host,q):
    while True:
        dst_port = q.get()

        track[host].append(dst_port)
        src_port = random.randint(1, 1025)
        ans, unans = sr(IP(dst=host) / TCP(sport=src_port, dport=dst_port, flags="S"), timeout=10, verbose=0)
        for p in ans:
            if p[1][TCP].flags == 'SA':
                with print_lock:
                    print("{}/tcp is open {}".format(p[1][TCP].sport, host))
        q.task_done()

def udp_scan(host,q):

    while True:
        dst_port = q.get()
        track[host].append(dst_port)
        src_port = random.randint(1, 1025)
        ans, unans = sr(IP(dst=host) / UDP(sport=src_port, dport=dst_port), retry = 3,timeout=10, verbose=0)
        for p in unans:
            with print_lock:
                print("{} udp is open/filtered on {}".format(p[1][UDP].dport,host))
        for p in ans:
            with print_lock:
                if p[1].haslayer(ICMP):
                    #print("{} udp is closed on {}".format(p[1][ICMP].dport, host))
                    pass
                elif p[1].haslayer(UDP):
                    print("{} udp is open on {}".format(p[1][UDP].sport,host))
        q.task_done()

def threader():
    while True:
        host = q1.get()
        track[host] = []
        q = Queue()
        for i in range(1,1025):
            q.put(i)
        for _ in range(5):
            if args.tcpsynscan:
                t1 = Mythread(func= port_scan, args=[host,q])
            if args.udpscan:
                t1 = Mythread(func=udp_scan, args=[host, q])
            t1.daemon = True
            t1.start()
        q.join()
        if q.empty() == True:
            q1.task_done()


def ping(host):

    ans, unans= sr(IP(dst=host)/ICMP(), retry=0,verbose=0, timeout=10)
    active_hosts = []
    for i in ans:
        if i[1][ICMP].type == 3:
            #print("From {} => {} Destination Host Unreachable".format(i[1][IP].src,i[1][IP][ICMP].dst))
            pass
        elif i[1][ICMP].type == 0:
            print("{} is alive".format(i[1][IP].src))
            active_hosts.append(i[1][IP].src)
    return active_hosts


hosts = []
q1 = Queue()

parser = argparse.ArgumentParser(description = 'Port Scanner')
parser.add_argument("ip_set",help="specify ip range")
parser.add_argument("-p","--ping",action="store_true",help="PingSweep")
parser.add_argument("-t","--tcpsynscan",action="store_true",help="TCP SYN Scan")
parser.add_argument("-u","--udpscan",action="store_true",help="UDP Scan")
args = parser.parse_args()
'''
print("~ ipset {}".format(args.ip_set) )
print("~ ping {}".format(args.ping))
print("~ tcp {}".format(args.tcpsynscan))
print("~ udp {}".format(args.udpscan))
'''

ip_set = args.ip_set.split(",")
if (len(ip_set) > 0):
    blocks = list(ip_set[0].split("."))
    for i in range(1, len(ip_set)):
        ip_set[i] = ".".join(blocks[:3]) + "." + ip_set[i]
    for hosts in ip_set:
        hosts = ping(hosts)
else:
    hosts = ping(sys.argv[1])

if args.tcpsynscan or args.udpscan:
    for x in hosts:
        q1.put(x)
    #Initializing Threads for portscanning
    for i in range(30):
        t = threading.Thread(name = "Thread-{}".format(i+1), target=threader)
        t.daemon = True
        t.start()


q1.join()
